# マップ探索（is_map_solvable）関数の解説

---

## 1. 目的

- ゲームのマップが「クリア可能」かどうかを自動で判定します。
- 具体的には、プレイヤーが全てのCとEに壁を避けて到達できるかを調べます。

---

## 2. 探索のイメージ

マップは2次元配列（例：下記）で表現されます。

```
11111
1P0C1
100E1
11111
```

- 1: 壁
- 0: 空きマス
- P: プレイヤー
- C: コレクタブル
- E: 出口

### 探索の流れ（DFS）

1. プレイヤーの位置からスタート
2. 上下左右に進める場所を再帰的にたどる
3. CやEに到達したらカウント
4. 全てのCとEに到達できたか判定

---

## 3. 図解

```
スタート: P

  1 1 1 1 1
  1 P 0 C 1
  1 0 0 E 1
  1 1 1 1 1

探索イメージ:

  1 1 1 1 1
  1 V V C 1
  1 V V E 1
  1 1 1 1 1

V: 訪問済み
```

---

## 4. コードの流れ

### 1. マップのコピー
- 探索中に元のマップを書き換えないよう、コピーを作ります。

### 2. プレイヤー位置の取得
- find_playerでPの座標(px, py)を取得します。

### 3. DFS探索
- dfs関数で、現在地から上下左右に進みます。
- 壁や訪問済みはスキップ。
- CやEに到達したらカウント。
- 訪問済みは'V'でマーク。

### 4. 結果判定
- 探索でカウントしたCとEの数が、元のマップのCとEの数と一致すればクリア可能。

---

## 5. コード例（抜粋）

```c
static void dfs(char **map, int x, int y, int *c_cnt, int *e_cnt, int width, int height) {
    if (x < 0 || y < 0 || x >= width || y >= height) return;
    if (map[y][x] == '1' || map[y][x] == 'V') return;
    if (map[y][x] == 'C') (*c_cnt)++;
    if (map[y][x] == 'E') (*e_cnt)++;
    map[y][x] = 'V';
    dfs(map, x+1, y, c_cnt, e_cnt, width, height);
    dfs(map, x-1, y, c_cnt, e_cnt, width, height);
    dfs(map, x, y+1, c_cnt, e_cnt, width, height);
    dfs(map, x, y-1, c_cnt, e_cnt, width, height);
}
```

---

## 6. まとめ
- プレイヤーから全てのCとEに到達できるかを、再帰的な探索（DFS）で判定しています。
- 迷路の「行ける場所を全部塗りつぶす」イメージです。
- これにより「クリア不可能なマップ」を自動で弾くことができます。

